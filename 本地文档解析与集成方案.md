# æœ¬åœ°æ–‡æ¡£è§£æä¸é›†æˆæ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› LabelMedix é¡¹ç›®çš„å®Œæ•´æœ¬åœ°æ–‡æ¡£è§£ææ–¹æ¡ˆï¼ŒåŒ…æ‹¬ PDF å’Œ Word æ–‡æ¡£çš„è§£æä¸é›†æˆæ–¹æ³•ã€‚

**æ ¸å¿ƒæ–¹æ¡ˆ**ï¼š

- **PDF è§£æ**ï¼šä½¿ç”¨ **pdfplumber**ï¼ˆPythonï¼‰
- **Word è§£æ**ï¼šä½¿ç”¨ **python-docx** + **LibreOffice**ï¼ˆ.doc è½¬ .docx åç»Ÿä¸€å¤„ç†ï¼‰

---

## ä¸€ã€æ–¹æ¡ˆæ€»è§ˆ

### 1.1 æŠ€æœ¯é€‰å‹

| æ–‡æ¡£ç±»å‹         | è§£ææ–¹æ¡ˆ                  | æŠ€æœ¯æ ˆ               | è¿è¡Œç¯å¢ƒ                    |
| ---------------- | ------------------------- | -------------------- | --------------------------- |
| **PDF**          | pdfplumber                | Python               | åç«¯ï¼ˆNode.js è°ƒç”¨ Pythonï¼‰ |
| **Word (.docx)** | python-docx               | Python               | åç«¯ï¼ˆNode.js è°ƒç”¨ Pythonï¼‰ |
| **Word (.doc)**  | LibreOffice + python-docx | LibreOffice + Python | åç«¯ï¼ˆå…ˆè½¬æ¢å†è§£æï¼‰        |

### 1.2 æ¶æ„è®¾è®¡

```
ç”¨æˆ·ä¸Šä¼ æ–‡æ¡£
    â†“
å‰ç«¯æ£€æµ‹æ–‡ä»¶ç±»å‹
    â†“
PDF? â”€â”€æ˜¯â”€â”€â†’ åç«¯è°ƒç”¨ pdfplumber è§£æ
    â”‚
   å¦
    â†“
Word (.docx)? â”€â”€æ˜¯â”€â”€â†’ åç«¯è°ƒç”¨ python-docx è§£æ
    â”‚
   å¦
    â†“
Word (.doc)? â”€â”€æ˜¯â”€â”€â†’ LibreOffice è½¬æ¢ä¸º .docx â†’ python-docx è§£æ
    â”‚
   å¦
    â†“
ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼
```

---

## äºŒã€PDF è§£ææ–¹æ¡ˆï¼ˆpdfplumberï¼‰

### 2.1 ä¸ºä»€ä¹ˆé€‰æ‹© pdfplumberï¼Ÿ

- âœ… **å¼ºå¤§çš„è¡¨æ ¼æå–èƒ½åŠ›**ï¼šç²¾ç¡®è¯†åˆ«è¡¨æ ¼ç»“æ„
- âœ… **ç²¾ç¡®çš„æ–‡æœ¬ä½ç½®ä¿¡æ¯**ï¼šä¿ç•™æ–‡æœ¬åæ ‡å’Œå¸ƒå±€
- âœ… **æ”¯æŒå¤æ‚å¸ƒå±€è¯†åˆ«**ï¼šå¤„ç†å¤šåˆ—ã€å¤æ‚æ’ç‰ˆ
- âœ… **æ¯”çº¯ JavaScript æ–¹æ¡ˆæ›´å‡†ç¡®**ï¼šPython ç”Ÿæ€æˆç†Ÿ

### 2.2 å®‰è£…å’Œé…ç½®

#### å®‰è£… Python ä¾èµ–

åˆ›å»º `BackEnd/python/requirements.txt`ï¼š

```txt
pdfplumber==0.10.3
pandas==2.1.4
python-docx==1.1.0
```

å®‰è£…ï¼š

```bash
cd BackEnd/python
pip install -r requirements.txt
```

### 2.3 Python è§£æè„šæœ¬

åˆ›å»º `BackEnd/python/pdf_parser.py`ï¼š

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PDFè§£æè„šæœ¬ - ä½¿ç”¨pdfplumberæå–æ–‡æœ¬å’Œè¡¨æ ¼
"""

import pdfplumber
import json
import sys
import os
from pathlib import Path

def parse_pdf(pdf_path):
    """
    è§£æPDFæ–‡ä»¶ï¼Œæå–æ–‡æœ¬å’Œè¡¨æ ¼ç»“æ„

    Args:
        pdf_path: PDFæ–‡ä»¶è·¯å¾„

    Returns:
        dict: åŒ…å«æ–‡æœ¬ã€è¡¨æ ¼ã€é¡µé¢ä¿¡æ¯çš„å­—å…¸
    """
    result = {
        "success": False,
        "text": "",
        "pages": [],
        "tables": [],
        "metadata": {},
        "error": None
    }

    try:
        with pdfplumber.open(pdf_path) as pdf:
            # æå–å…ƒæ•°æ®
            result["metadata"] = {
                "num_pages": len(pdf.pages),
                "metadata": pdf.metadata or {}
            }

            full_text = ""

            # éå†æ¯ä¸€é¡µ
            for page_num, page in enumerate(pdf.pages, start=1):
                page_data = {
                    "page_number": page_num,
                    "text": "",
                    "tables": [],
                    "width": page.width,
                    "height": page.height
                }

                # æå–æ–‡æœ¬
                page_text = page.extract_text() or ""
                page_data["text"] = page_text
                full_text += page_text + "\n"

                # æå–è¡¨æ ¼
                tables = page.extract_tables()
                for table_num, table in enumerate(tables):
                    table_data = {
                        "page": page_num,
                        "table_number": table_num + 1,
                        "rows": table,
                        "row_count": len(table),
                        "col_count": len(table[0]) if table else 0
                    }
                    page_data["tables"].append(table_data)
                    result["tables"].append(table_data)

                result["pages"].append(page_data)

            result["text"] = full_text.strip()
            result["success"] = True

    except Exception as e:
        result["error"] = str(e)
        result["success"] = False

    return result

def parse_structured_content(text, tables):
    """
    æ ¹æ®é¡¹ç›®éœ€æ±‚ï¼Œè§£æç»“æ„åŒ–å†…å®¹ï¼ˆä¸‰åˆ—ç»“æ„ã€åŒåˆ—ç»“æ„ç­‰ï¼‰

    Args:
        text: æå–çš„æ–‡æœ¬
        tables: æå–çš„è¡¨æ ¼

    Returns:
        dict: ç»“æ„åŒ–æ•°æ®
    """
    structured = {
        "three_column_structure": [],
        "two_column_structure": [],
        "single_column": []
    }

    # å¦‚æœæœ‰è¡¨æ ¼ï¼Œä¼˜å…ˆä½¿ç”¨è¡¨æ ¼æ•°æ®
    if tables:
        for table in tables:
            rows = table.get("rows", [])
            if len(rows) > 0:
                # åˆ¤æ–­è¡¨æ ¼åˆ—æ•°
                col_count = table.get("col_count", 0)
                if col_count == 3:
                    # ä¸‰åˆ—ç»“æ„ï¼šReg Template, Original English, Translation
                    for row in rows:
                        if len(row) >= 3:
                            structured["three_column_structure"].append({
                                "reg_template": row[0] or "",
                                "original_english": row[1] or "",
                                "translation": row[2] or ""
                            })
                elif col_count == 2:
                    # åŒåˆ—ç»“æ„ï¼šEnglish Phrase, Translation
                    for row in rows:
                        if len(row) >= 2:
                            structured["two_column_structure"].append({
                                "english_phrase": row[0] or "",
                                "translation": row[1] or ""
                            })

    # å¦‚æœæ²¡æœ‰è¡¨æ ¼ï¼Œå°è¯•ä»æ–‡æœ¬ä¸­è§£æ
    if not tables and text:
        lines = text.split("\n")
        # æ ¹æ®é¡¹ç›®è§„åˆ™è§£ææ–‡æœ¬ç»“æ„
        # ... è§£æé€»è¾‘

    return structured

def main():
    """ä¸»å‡½æ•° - ä»å‘½ä»¤è¡Œå‚æ•°è·å–PDFè·¯å¾„"""
    if len(sys.argv) < 2:
        print(json.dumps({
            "success": False,
            "error": "è¯·æä¾›PDFæ–‡ä»¶è·¯å¾„"
        }), file=sys.stderr)
        sys.exit(1)

    pdf_path = sys.argv[1]

    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if not os.path.exists(pdf_path):
        print(json.dumps({
            "success": False,
            "error": f"æ–‡ä»¶ä¸å­˜åœ¨: {pdf_path}"
        }), file=sys.stderr)
        sys.exit(1)

    # è§£æPDF
    result = parse_pdf(pdf_path)

    # è§£æç»“æ„åŒ–å†…å®¹
    if result["success"]:
        result["structured"] = parse_structured_content(
            result["text"],
            result["tables"]
        )

    # è¾“å‡ºJSONç»“æœ
    print(json.dumps(result, ensure_ascii=False, indent=2))

    # æ ¹æ®æˆåŠŸä¸å¦è®¾ç½®é€€å‡ºç 
    sys.exit(0 if result["success"] else 1)

if __name__ == "__main__":
    main()
```

---

## ä¸‰ã€Word è§£ææ–¹æ¡ˆï¼ˆpython-docx + LibreOfficeï¼‰

### 3.1 æ–¹æ¡ˆè®¾è®¡

**æ ¸å¿ƒæ€è·¯**ï¼šç»Ÿä¸€ä½¿ç”¨ python-docx å¤„ç†æ‰€æœ‰ Word æ–‡æ¡£

- **.docx æ–‡ä»¶**ï¼šç›´æ¥ä½¿ç”¨ python-docx è§£æ
- **.doc æ–‡ä»¶**ï¼šå…ˆä½¿ç”¨ LibreOffice è½¬æ¢ä¸º .docxï¼Œå†ä½¿ç”¨ python-docx è§£æ

**ä¼˜åŠ¿**ï¼š

- âœ… ä»£ç ä¸€è‡´æ€§ï¼šåªä½¿ç”¨ python-docx
- âœ… ç»“æ„ä¿¡æ¯å®Œæ•´ï¼šè½¬æ¢åä¿æŒè¡¨æ ¼å’Œæ ¼å¼
- âœ… ç»´æŠ¤ç®€å•ï¼šåªéœ€è¦ç»´æŠ¤ä¸€å¥—è§£æé€»è¾‘

### 3.2 LibreOffice å®‰è£…å’Œé…ç½®

#### Ubuntu/Debian

**é‡è¦è¯´æ˜**ï¼š

- âœ… **æ¡Œé¢ç‰ˆ Ubuntu**ï¼šé€šå¸¸**é»˜è®¤å·²å®‰è£…** LibreOffice
- âŒ **æœåŠ¡å™¨ç‰ˆ Ubuntu**ï¼šé€šå¸¸**ä¸å®‰è£…**ï¼ˆæ— å›¾å½¢ç•Œé¢ï¼‰
- âŒ **Docker å®¹å™¨**ï¼šé€šå¸¸**ä¸å®‰è£…**

**æ£€æŸ¥æ˜¯å¦å·²å®‰è£…**ï¼š

```bash
# æ£€æŸ¥ LibreOffice æ˜¯å¦å·²å®‰è£…
which soffice
# æˆ–
soffice --version
```

**å¦‚æœæœªå®‰è£…ï¼Œåˆ™å®‰è£…**ï¼š

```bash
# å®‰è£…å®Œæ•´ç‰ˆï¼ˆåŒ…å«æ‰€æœ‰ç»„ä»¶ï¼‰
sudo apt-get update
sudo apt-get install libreoffice

# æˆ–ä»…å®‰è£…æ ¸å¿ƒç»„ä»¶ï¼ˆæ›´è½»é‡ï¼Œé€‚åˆæœåŠ¡å™¨ï¼‰
sudo apt-get install libreoffice-core libreoffice-writer
```

#### macOS

```bash
# ä½¿ç”¨ Homebrew å®‰è£…
brew install --cask libreoffice
```

#### Windows

- ä»å®˜ç½‘ä¸‹è½½å®‰è£…ï¼šhttps://www.libreoffice.org/download/
- å®‰è£…åç¡®ä¿ `soffice` å‘½ä»¤åœ¨ PATH ä¸­

### 3.3 .doc è½¬ .docx è½¬æ¢è„šæœ¬

åˆ›å»º `BackEnd/python/doc_to_docx.py`ï¼š

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
.doc è½¬ .docx è½¬æ¢è„šæœ¬
ä½¿ç”¨ LibreOffice å‘½ä»¤è¡Œå·¥å…·è¿›è¡Œè½¬æ¢
"""

import subprocess
import sys
import os
from pathlib import Path
import tempfile
import shutil

def find_libreoffice():
    """æŸ¥æ‰¾ LibreOffice å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„"""
    possible_paths = [
        'soffice',  # å¦‚æœåœ¨ PATH ä¸­
        '/Applications/LibreOffice.app/Contents/MacOS/soffice',  # macOS
        'C:\\Program Files\\LibreOffice\\program\\soffice.exe',  # Windows
        '/usr/bin/soffice',  # Linux
        '/usr/local/bin/soffice',  # Linux
    ]

    for path in possible_paths:
        if os.path.exists(path) or shutil.which(path):
            return path

    return None

def convert_doc_to_docx(doc_path, output_dir=None):
    """
    ä½¿ç”¨ LibreOffice å°† .doc è½¬æ¢ä¸º .docx

    Args:
        doc_path: .doc æ–‡ä»¶è·¯å¾„
        output_dir: è¾“å‡ºç›®å½•ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸æºæ–‡ä»¶åŒç›®å½•ï¼‰

    Returns:
        str: è½¬æ¢åçš„ .docx æ–‡ä»¶è·¯å¾„
    """
    doc_path = Path(doc_path)

    if not doc_path.exists():
        raise FileNotFoundError(f"æ–‡ä»¶ä¸å­˜åœ¨: {doc_path}")

    if doc_path.suffix.lower() != '.doc':
        raise ValueError(f"æ–‡ä»¶ä¸æ˜¯ .doc æ ¼å¼: {doc_path}")

    # æŸ¥æ‰¾ LibreOffice
    soffice_path = find_libreoffice()
    if not soffice_path:
        raise RuntimeError(
            "æœªæ‰¾åˆ° LibreOfficeã€‚è¯·å®‰è£… LibreOffice å¹¶ç¡®ä¿ 'soffice' å‘½ä»¤å¯ç”¨ã€‚\n"
            "å®‰è£…æ–¹æ³•ï¼š\n"
            "  macOS: brew install --cask libreoffice\n"
            "  Ubuntu: sudo apt-get install libreoffice\n"
            "  Windows: ä» https://www.libreoffice.org/download/ ä¸‹è½½å®‰è£…"
        )

    # ç¡®å®šè¾“å‡ºç›®å½•
    if output_dir is None:
        output_dir = doc_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

    # ä½¿ç”¨ä¸´æ—¶ç›®å½•è¿›è¡Œè½¬æ¢ï¼ˆLibreOffice ä¼šåœ¨åŒä¸€ç›®å½•ç”Ÿæˆæ–‡ä»¶ï¼‰
    with tempfile.TemporaryDirectory() as temp_dir:
        # å¤åˆ¶æºæ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•
        temp_doc = Path(temp_dir) / doc_path.name
        shutil.copy2(doc_path, temp_doc)

        # æ„å»º LibreOffice å‘½ä»¤
        # --headless: æ— ç•Œé¢æ¨¡å¼
        # --convert-to docx: è½¬æ¢ä¸º docx æ ¼å¼
        # --outdir: è¾“å‡ºç›®å½•
        cmd = [
            soffice_path,
            '--headless',
            '--convert-to', 'docx',
            '--outdir', str(temp_dir),
            str(temp_doc)
        ]

        try:
            # æ‰§è¡Œè½¬æ¢
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60,  # 60ç§’è¶…æ—¶
                check=True
            )

            # æŸ¥æ‰¾è½¬æ¢åçš„æ–‡ä»¶
            docx_file = temp_dir / (doc_path.stem + '.docx')

            if not docx_file.exists():
                raise RuntimeError(f"è½¬æ¢å¤±è´¥ï¼šæœªæ‰¾åˆ°è¾“å‡ºæ–‡ä»¶ {docx_file}")

            # å¤åˆ¶åˆ°ç›®æ ‡ç›®å½•
            output_docx = output_dir / (doc_path.stem + '.docx')
            shutil.copy2(docx_file, output_docx)

            return str(output_docx)

        except subprocess.TimeoutExpired:
            raise RuntimeError("è½¬æ¢è¶…æ—¶ï¼ˆè¶…è¿‡60ç§’ï¼‰")
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"è½¬æ¢å¤±è´¥: {e.stderr}")
        except Exception as e:
            raise RuntimeError(f"è½¬æ¢è¿‡ç¨‹å‡ºé”™: {str(e)}")

def main():
    """ä¸»å‡½æ•°"""
    if len(sys.argv) < 2:
        print("ç”¨æ³•: python doc_to_docx.py <docæ–‡ä»¶è·¯å¾„> [è¾“å‡ºç›®å½•]", file=sys.stderr)
        sys.exit(1)

    doc_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else None

    try:
        docx_path = convert_doc_to_docx(doc_path, output_dir)
        print(docx_path)
        sys.exit(0)
    except Exception as e:
        print(f"é”™è¯¯: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### 3.4 Word è§£æè„šæœ¬ï¼ˆç»Ÿä¸€ä½¿ç”¨ python-docxï¼‰

åˆ›å»º `BackEnd/python/word_parser.py`ï¼š

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Wordæ–‡æ¡£è§£æè„šæœ¬ - ç»Ÿä¸€ä½¿ç”¨ python-docx
è‡ªåŠ¨å°† .doc è½¬æ¢ä¸º .docx
"""

import sys
import json
import os
from pathlib import Path
import tempfile
import shutil

# å¯¼å…¥è½¬æ¢å‡½æ•°
from doc_to_docx import convert_doc_to_docx

def parse_word_with_docx(file_path):
    """
    ä½¿ç”¨ python-docx è§£æ Word æ–‡æ¡£

    Args:
        file_path: Wordæ–‡ä»¶è·¯å¾„ï¼ˆ.docx æˆ– .docï¼‰

    Returns:
        dict: è§£æç»“æœ
    """
    try:
        from docx import Document
    except ImportError:
        return {
            "success": False,
            "error": "python-docx æœªå®‰è£…ï¼Œè¯·è¿è¡Œ: pip install python-docx"
        }

    result = {
        "success": False,
        "text": "",
        "paragraphs": [],
        "tables": [],
        "error": None,
        "converted": False  # æ ‡è®°æ˜¯å¦è¿›è¡Œäº†è½¬æ¢
    }

    file_path = Path(file_path)
    original_path = file_path
    temp_docx = None

    try:
        # å¦‚æœæ˜¯ .doc æ ¼å¼ï¼Œå…ˆè½¬æ¢ä¸º .docx
        if file_path.suffix.lower() == '.doc':
            print(f"ğŸ“„ æ£€æµ‹åˆ° .doc æ ¼å¼ï¼Œå¼€å§‹è½¬æ¢ä¸º .docx...", file=sys.stderr)
            try:
                # è½¬æ¢åˆ°ä¸´æ—¶ç›®å½•
                temp_dir = tempfile.mkdtemp()
                docx_path = convert_doc_to_docx(str(file_path), temp_dir)
                file_path = Path(docx_path)
                temp_docx = file_path  # è®°å½•ä¸´æ—¶æ–‡ä»¶ï¼Œç¨ååˆ é™¤
                result["converted"] = True
                print(f"âœ… è½¬æ¢æˆåŠŸ: {file_path}", file=sys.stderr)
            except Exception as e:
                return {
                    "success": False,
                    "error": f".doc è½¬ .docx å¤±è´¥: {str(e)}"
                }

        # ä½¿ç”¨ python-docx è§£æ
        doc = Document(file_path)

        full_text = ""
        paragraphs = []
        tables = []

        # æå–æ®µè½
        for para in doc.paragraphs:
            para_text = para.text.strip()
            if para_text:
                paragraphs.append({
                    "text": para_text,
                    "style": para.style.name if para.style else None
                })
                full_text += para_text + "\n"

        # æå–è¡¨æ ¼
        for table_idx, table in enumerate(doc.tables):
            table_data = {
                "index": table_idx,
                "rows": []
            }

            for row in table.rows:
                row_data = [cell.text.strip() for cell in row.cells]
                table_data["rows"].append(row_data)

            tables.append(table_data)

        result["text"] = full_text.strip()
        result["paragraphs"] = paragraphs
        result["tables"] = tables
        result["success"] = True

    except Exception as e:
        result["error"] = str(e)
        result["success"] = False

    finally:
        # æ¸…ç†ä¸´æ—¶è½¬æ¢æ–‡ä»¶
        if temp_docx and temp_docx.exists():
            try:
                # åˆ é™¤ä¸´æ—¶æ–‡ä»¶åŠå…¶ç›®å½•
                temp_docx.unlink()
                temp_docx.parent.rmdir()
            except Exception as e:
                print(f"âš ï¸ æ¸…ç†ä¸´æ—¶æ–‡ä»¶å¤±è´¥: {e}", file=sys.stderr)

    return result

def parse_structured_content(text, tables=None):
    """
    æ ¹æ®é¡¹ç›®éœ€æ±‚ï¼Œè§£æç»“æ„åŒ–å†…å®¹ï¼ˆä¸‰åˆ—ç»“æ„ã€åŒåˆ—ç»“æ„ç­‰ï¼‰

    Args:
        text: æå–çš„æ–‡æœ¬
        tables: æå–çš„è¡¨æ ¼ï¼ˆå¯é€‰ï¼‰

    Returns:
        dict: ç»“æ„åŒ–æ•°æ®
    """
    structured = {
        "three_column_structure": [],
        "two_column_structure": [],
        "single_column": []
    }

    # å¦‚æœæœ‰è¡¨æ ¼ï¼Œä¼˜å…ˆä½¿ç”¨è¡¨æ ¼æ•°æ®
    if tables:
        for table in tables:
            rows = table.get("rows", [])
            if len(rows) > 0:
                first_row = rows[0] if rows else []
                col_count = len(first_row)

                if col_count == 3:
                    # ä¸‰åˆ—ç»“æ„ï¼šReg Template, Original English, Translation
                    for row in rows:
                        if len(row) >= 3:
                            structured["three_column_structure"].append({
                                "reg_template": row[0] or "",
                                "original_english": row[1] or "",
                                "translation": row[2] or ""
                            })
                elif col_count == 2:
                    # åŒåˆ—ç»“æ„ï¼šEnglish Phrase, Translation
                    for row in rows:
                        if len(row) >= 2:
                            structured["two_column_structure"].append({
                                "english_phrase": row[0] or "",
                                "translation": row[1] or ""
                            })

    # å¦‚æœæ²¡æœ‰è¡¨æ ¼ï¼Œå°è¯•ä»æ–‡æœ¬ä¸­è§£æ
    if not tables and text:
        lines = text.split("\n")
        # æ ¹æ®é¡¹ç›®è§„åˆ™è§£ææ–‡æœ¬ç»“æ„
        # ... è§£æé€»è¾‘

    return structured

def main():
    """ä¸»å‡½æ•°"""
    if len(sys.argv) < 2:
        print(json.dumps({
            "success": False,
            "error": "è¯·æä¾›Wordæ–‡ä»¶è·¯å¾„"
        }), file=sys.stderr)
        sys.exit(1)

    file_path = sys.argv[1]

    if not os.path.exists(file_path):
        print(json.dumps({
            "success": False,
            "error": f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}"
        }), file=sys.stderr)
        sys.exit(1)

    # è§£æWordæ–‡æ¡£ï¼ˆè‡ªåŠ¨å¤„ç† .doc è½¬æ¢ï¼‰
    result = parse_word_with_docx(file_path)

    # è§£æç»“æ„åŒ–å†…å®¹
    if result["success"]:
        tables = result.get("tables", None)
        result["structured"] = parse_structured_content(
            result["text"],
            tables
        )

    # è¾“å‡ºJSONç»“æœ
    print(json.dumps(result, ensure_ascii=False, indent=2))

    sys.exit(0 if result["success"] else 1)

if __name__ == "__main__":
    main()
```

---

## å››ã€Node.js åç«¯é›†æˆ

### 4.1 åˆ›å»ºæ–‡æ¡£è§£ææœåŠ¡

åˆ›å»º `BackEnd/src/services/documentParserService.js`ï¼š

```javascript
const { exec } = require("child_process");
const { promisify } = require("util");
const path = require("path");
const fs = require("fs").promises;

const execAsync = promisify(exec);

/**
 * ä½¿ç”¨Pythonè§£ææ–‡æ¡£ï¼ˆPDFæˆ–Wordï¼‰
 * @param {string} filePath - æ–‡ä»¶è·¯å¾„
 * @param {string} fileType - æ–‡ä»¶ç±»å‹ï¼š'pdf' | 'word'
 * @returns {Promise<Object>} è§£æç»“æœ
 */
async function parseDocumentWithPython(filePath, fileType) {
  const pythonDir = path.join(__dirname, "../../python");
  let pythonScriptPath;

  if (fileType === "pdf") {
    pythonScriptPath = path.join(pythonDir, "pdf_parser.py");
  } else if (fileType === "word") {
    pythonScriptPath = path.join(pythonDir, "word_parser.py");
  } else {
    throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${fileType}`);
  }

  // æ£€æŸ¥Pythonè„šæœ¬æ˜¯å¦å­˜åœ¨
  try {
    await fs.access(pythonScriptPath);
  } catch (error) {
    throw new Error(`Pythonè„šæœ¬ä¸å­˜åœ¨: ${pythonScriptPath}`);
  }

  // è°ƒç”¨Pythonè„šæœ¬
  const pythonCommand = `python3 "${pythonScriptPath}" "${filePath}"`;
  // Windows: const pythonCommand = `python "${pythonScriptPath}" "${filePath}"`;

  console.log(`ğŸ è°ƒç”¨Pythonè§£æ${fileType.toUpperCase()}: ${filePath}`);

  try {
    const { stdout, stderr } = await execAsync(pythonCommand, {
      maxBuffer: 10 * 1024 * 1024, // 10MBç¼“å†²åŒº
      encoding: "utf8",
    });

    if (stderr) {
      console.warn("âš ï¸ Pythonè„šæœ¬è­¦å‘Š:", stderr);
    }

    // è§£æJSONç»“æœ
    const result = JSON.parse(stdout);

    if (!result.success) {
      throw new Error(result.error || `${fileType.toUpperCase()}è§£æå¤±è´¥`);
    }

    return result;
  } catch (error) {
    console.error(`âŒ ${fileType.toUpperCase()}è§£æå¤±è´¥:`, error);
    throw new Error(`${fileType.toUpperCase()}è§£æå¤±è´¥: ${error.message}`);
  }
}

/**
 * æ£€æµ‹Pythonç¯å¢ƒæ˜¯å¦å¯ç”¨
 * @returns {Promise<boolean>}
 */
async function checkPythonEnvironment() {
  try {
    const { stdout } = await execAsync("python3 --version");
    console.log("âœ… Pythonç¯å¢ƒ:", stdout.trim());
    return true;
  } catch (error) {
    try {
      const { stdout } = await execAsync("python --version");
      console.log("âœ… Pythonç¯å¢ƒ:", stdout.trim());
      return true;
    } catch (error2) {
      console.error("âŒ Pythonç¯å¢ƒä¸å¯ç”¨");
      return false;
    }
  }
}

/**
 * æ£€æŸ¥LibreOfficeæ˜¯å¦å¯ç”¨
 * @returns {Promise<boolean>}
 */
async function checkLibreOffice() {
  try {
    await execAsync("soffice --version");
    console.log("âœ… LibreOfficeå¯ç”¨");
    return true;
  } catch (error) {
    console.warn("âš ï¸ LibreOfficeä¸å¯ç”¨ï¼ˆ.docæ–‡ä»¶è½¬æ¢éœ€è¦ï¼‰");
    return false;
  }
}

module.exports = {
  parseDocumentWithPython,
  checkPythonEnvironment,
  checkLibreOffice,
};
```

### 4.2 åˆ›å»º API è·¯ç”±

åˆ›å»º `BackEnd/src/routes/documentParser.js`ï¼š

```javascript
const express = require("express");
const multer = require("multer");
const path = require("path");
const fs = require("fs").promises;
const documentParserService = require("../services/documentParserService");

const router = express.Router();

// é…ç½®multerç”¨äºæ–‡ä»¶ä¸Šä¼ 
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(__dirname, "../../uploads/temp");
    await fs.mkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname);
    cb(null, `doc-${uniqueSuffix}${ext}`);
  },
});

const upload = multer({
  storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MBé™åˆ¶
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if ([".pdf", ".doc", ".docx"].includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error("åªæ”¯æŒ PDFã€.doc å’Œ .docx æ–‡ä»¶"), false);
    }
  },
});

/**
 * POST /api/document-parser/parse
 * è§£ææ–‡æ¡£ï¼ˆPDFæˆ–Wordï¼‰
 */
router.post("/parse", upload.single("document"), async (req, res) => {
  let tempFilePath = null;

  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "è¯·ä¸Šä¼ æ–‡æ¡£æ–‡ä»¶",
      });
    }

    tempFilePath = req.file.path;
    const fileExt = path.extname(req.file.originalname).toLowerCase();

    // ç¡®å®šæ–‡ä»¶ç±»å‹
    let fileType;
    if (fileExt === ".pdf") {
      fileType = "pdf";
    } else if ([".doc", ".docx"].includes(fileExt)) {
      fileType = "word";
    } else {
      return res.status(400).json({
        success: false,
        message: `ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: ${fileExt}`,
      });
    }

    console.log(
      `ğŸ“„ æ”¶åˆ°${fileType.toUpperCase()}æ–‡ä»¶: ${
        req.file.originalname
      } (${fileExt})`
    );

    // è°ƒç”¨Pythonè§£æ
    const result = await documentParserService.parseDocumentWithPython(
      tempFilePath,
      fileType
    );

    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    await fs.unlink(tempFilePath).catch(() => {});

    res.json({
      success: true,
      data: result,
      fileType: fileType,
      fileExtension: fileExt,
    });
  } catch (error) {
    console.error("âŒ æ–‡æ¡£è§£æå¤±è´¥:", error);

    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    if (tempFilePath) {
      await fs.unlink(tempFilePath).catch(() => {});
    }

    res.status(500).json({
      success: false,
      message: "æ–‡æ¡£è§£æå¤±è´¥",
      error: error.message,
    });
  }
});

/**
 * GET /api/document-parser/check
 * æ£€æŸ¥è§£æç¯å¢ƒ
 */
router.get("/check", async (req, res) => {
  try {
    const pythonAvailable =
      await documentParserService.checkPythonEnvironment();
    const libreOfficeAvailable = await documentParserService.checkLibreOffice();

    res.json({
      success: true,
      pythonAvailable,
      libreOfficeAvailable,
      message: libreOfficeAvailable
        ? "ç¯å¢ƒæ£€æŸ¥é€šè¿‡ï¼Œæ”¯æŒæ‰€æœ‰æ–‡æ¡£æ ¼å¼"
        : "Pythonå¯ç”¨ï¼Œä½†LibreOfficeä¸å¯ç”¨ï¼ˆ.docæ–‡ä»¶è½¬æ¢éœ€è¦LibreOfficeï¼‰",
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "æ£€æŸ¥ç¯å¢ƒå¤±è´¥",
      error: error.message,
    });
  }
});

module.exports = router;
```

### 4.3 æ³¨å†Œè·¯ç”±

æ›´æ–° `BackEnd/src/app.js`ï¼š

```javascript
// ... ç°æœ‰ä»£ç  ...

// å¯¼å…¥è·¯ç”±
const projectRoutes = require("./routes/projects");
const fieldTypeKeywordsRoutes = require("./routes/fieldTypeKeywords");
const labelSettingsRoutes = require("./routes/labelSettings");
const documentParserRoutes = require("./routes/documentParser"); // æ–°å¢

// ... ç°æœ‰ä»£ç  ...

// API è·¯ç”±
app.use("/api/projects", projectRoutes);
app.use("/api/field-type-keywords", fieldTypeKeywordsRoutes);
app.use("/api/label-settings", labelSettingsRoutes);
app.use("/api/document-parser", documentParserRoutes); // æ–°å¢

// ... ç°æœ‰ä»£ç  ...
```

### 4.4 å®‰è£…ä¾èµ–

```bash
cd BackEnd
cnpm install multer
```

---

## äº”ã€å‰ç«¯é›†æˆ

### 5.1 åˆ›å»ºå‰ç«¯ API è°ƒç”¨

åˆ›å»º `FrontEnd/lib/documentParserApi.ts`ï¼š

```typescript
/**
 * è°ƒç”¨åç«¯æ–‡æ¡£è§£æAPI
 */
export interface ParseResult {
  success: boolean;
  data?: {
    text: string;
    pages?: Array<{
      pageNumber: number;
      text: string;
      tables?: Array<any>;
    }>;
    paragraphs?: Array<{
      text: string;
      style?: string;
    }>;
    tables?: Array<{
      index: number;
      rows: Array<Array<string>>;
    }>;
    structured?: {
      three_column_structure?: Array<any>;
      two_column_structure?: Array<any>;
      single_column?: Array<any>;
    };
    converted?: boolean; // Word .doc è½¬æ¢æ ‡è®°
  };
  fileType?: "pdf" | "word";
  fileExtension?: string;
  error?: string;
}

export async function parseDocument(file: File): Promise<ParseResult> {
  const formData = new FormData();
  formData.append("document", file);

  const response = await fetch(
    `${process.env.NEXT_PUBLIC_API_BASE_URL}/api/document-parser/parse`,
    {
      method: "POST",
      body: formData,
    }
  );

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || `æ–‡æ¡£è§£æå¤±è´¥: ${response.statusText}`);
  }

  const result = await response.json();
  return result;
}

/**
 * æ£€æŸ¥è§£æç¯å¢ƒ
 */
export async function checkParserEnvironment() {
  const response = await fetch(
    `${process.env.NEXT_PUBLIC_API_BASE_URL}/api/document-parser/check`
  );
  const result = await response.json();
  return result;
}
```

### 5.2 æ›´æ–° ProjectList ç»„ä»¶

åœ¨ `FrontEnd/app/components/ProjectList.tsx` ä¸­é›†æˆï¼š

```typescript
import { parseDocument } from "@/lib/documentParserApi";
import { batchProcessFiles } from "@/lib/cozeApi";

// åœ¨æ–‡ä»¶å¤„ç†é€»è¾‘ä¸­
const handleFileUpload = async (files: File[]) => {
  // åˆ†ç¦»PDFå’ŒWordæ–‡ä»¶
  const pdfFiles = files.filter((f) => f.name.endsWith(".pdf"));
  const wordFiles = files.filter(
    (f) => f.name.endsWith(".docx") || f.name.endsWith(".doc")
  );

  // å¤„ç†PDFæ–‡ä»¶
  if (pdfFiles.length > 0) {
    const results = await Promise.all(
      pdfFiles.map((file) => parseDocument(file))
    );
    // å¤„ç†è§£æç»“æœ...
  }

  // å¤„ç†Wordæ–‡ä»¶
  if (wordFiles.length > 0) {
    const results = await Promise.all(
      wordFiles.map((file) => parseDocument(file))
    );
    // å¤„ç†è§£æç»“æœ...
  }

  // å¦‚æœè¿˜æœ‰å…¶ä»–æ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨Coze APIä½œä¸ºå¤‡é€‰
  // ...
};
```

---

## å…­ã€å®Œæ•´å¤„ç†æµç¨‹

### 6.1 PDF å¤„ç†æµç¨‹

```
ç”¨æˆ·ä¸Šä¼ PDFæ–‡ä»¶
    â†“
å‰ç«¯æ£€æµ‹åˆ°PDFæ ¼å¼
    â†“
è°ƒç”¨åç«¯API (/api/document-parser/parse)
    â†“
åç«¯ä¿å­˜ä¸´æ—¶æ–‡ä»¶
    â†“
è°ƒç”¨Pythonè„šæœ¬ (pdf_parser.py)
    â†“
ä½¿ç”¨pdfplumberè§£æPDF
    â†“
æå–æ–‡æœ¬å’Œè¡¨æ ¼
    â†“
è¿”å›JSONç»“æœ
    â†“
Node.jså¤„ç†ç»“æœå¹¶è¿”å›å‰ç«¯
    â†“
æ¸…ç†ä¸´æ—¶æ–‡ä»¶
```

### 6.2 Word å¤„ç†æµç¨‹

#### .docx æ–‡ä»¶

```
ç”¨æˆ·ä¸Šä¼ .docxæ–‡ä»¶
    â†“
å‰ç«¯æ£€æµ‹åˆ°.docxæ ¼å¼
    â†“
è°ƒç”¨åç«¯API
    â†“
åç«¯ä¿å­˜ä¸´æ—¶æ–‡ä»¶
    â†“
è°ƒç”¨Pythonè„šæœ¬ (word_parser.py)
    â†“
ä½¿ç”¨python-docxè§£æ
    â†“
æå–æ®µè½å’Œè¡¨æ ¼
    â†“
è¿”å›JSONç»“æœ
    â†“
æ¸…ç†ä¸´æ—¶æ–‡ä»¶
```

#### .doc æ–‡ä»¶

```
ç”¨æˆ·ä¸Šä¼ .docæ–‡ä»¶
    â†“
å‰ç«¯æ£€æµ‹åˆ°.docæ ¼å¼
    â†“
è°ƒç”¨åç«¯API
    â†“
åç«¯ä¿å­˜ä¸´æ—¶æ–‡ä»¶
    â†“
è°ƒç”¨Pythonè„šæœ¬ (word_parser.py)
    â†“
æ£€æµ‹åˆ°.docæ ¼å¼
    â†“
è°ƒç”¨LibreOfficeè½¬æ¢ä¸º.docx
    â†“
ä½¿ç”¨python-docxè§£æè½¬æ¢åçš„æ–‡ä»¶
    â†“
æå–æ®µè½å’Œè¡¨æ ¼
    â†“
æ¸…ç†ä¸´æ—¶æ–‡ä»¶ï¼ˆåŒ…æ‹¬è½¬æ¢åçš„.docxï¼‰
    â†“
è¿”å›JSONç»“æœ
```

---

## ä¸ƒã€ç¯å¢ƒé…ç½®

### 7.1 Python ä¾èµ–

åˆ›å»º `BackEnd/python/requirements.txt`ï¼š

```txt
# PDFè§£æ
pdfplumber==0.10.3
pandas==2.1.4

# Wordè§£æ
python-docx==1.1.0
```

å®‰è£…ï¼š

```bash
cd BackEnd/python
pip install -r requirements.txt
```

### 7.2 ç³»ç»Ÿä¾èµ–

#### LibreOfficeï¼ˆç”¨äº .doc è½¬æ¢ï¼‰

**Ubuntu/Debian**ï¼š

```bash
# æ£€æŸ¥æ˜¯å¦å·²å®‰è£…
which soffice

# å¦‚æœæœªå®‰è£…
sudo apt-get update
sudo apt-get install libreoffice-core libreoffice-writer
```

**macOS**ï¼š

```bash
brew install --cask libreoffice
```

**Windows**ï¼š

- ä»å®˜ç½‘ä¸‹è½½å®‰è£…ï¼šhttps://www.libreoffice.org/download/

### 7.3 Node.js ä¾èµ–

```bash
cd BackEnd
cnpm install multer
```

---

## å…«ã€Docker éƒ¨ç½²é…ç½®

### 8.1 Dockerfile ç¤ºä¾‹

åˆ›å»º `BackEnd/python/Dockerfile`ï¼š

```dockerfile
FROM python:3.11-slim

# å®‰è£…LibreOfficeï¼ˆç”¨äº.docè½¬.docxï¼‰
RUN apt-get update && \
    apt-get install -y libreoffice-core libreoffice-writer && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# å®‰è£…Pythonä¾èµ–
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶è„šæœ¬
COPY pdf_parser.py word_parser.py doc_to_docx.py ./

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app
```

### 8.2 requirements.txt

```txt
pdfplumber==0.10.3
pandas==2.1.4
python-docx==1.1.0
```

---

## ä¹ã€æ–¹æ¡ˆä¼˜åŠ¿æ€»ç»“

### 9.1 PDF è§£æï¼ˆpdfplumberï¼‰

- âœ… **å¼ºå¤§çš„è¡¨æ ¼æå–**ï¼šç²¾ç¡®è¯†åˆ«è¡¨æ ¼ç»“æ„
- âœ… **æ–‡æœ¬ä½ç½®ä¿¡æ¯**ï¼šä¿ç•™åæ ‡å’Œå¸ƒå±€
- âœ… **å¤æ‚å¸ƒå±€æ”¯æŒ**ï¼šå¤„ç†å¤šåˆ—ã€å¤æ‚æ’ç‰ˆ
- âœ… **Python ç”Ÿæ€æˆç†Ÿ**ï¼šç¨³å®šå¯é 

### 9.2 Word è§£æï¼ˆpython-docx + LibreOfficeï¼‰

- âœ… **ä»£ç ä¸€è‡´æ€§**ï¼šç»Ÿä¸€ä½¿ç”¨ python-docx
- âœ… **æ ¼å¼ä¿æŒå®Œæ•´**ï¼šè½¬æ¢åä¿æŒè¡¨æ ¼å’Œæ ¼å¼
- âœ… **ç»´æŠ¤ç®€å•**ï¼šåªéœ€ç»´æŠ¤ä¸€å¥—è§£æé€»è¾‘
- âœ… **åŠŸèƒ½å®Œæ•´**ï¼šæä¾›æ®µè½ã€è¡¨æ ¼ç­‰å®Œæ•´ç»“æ„

### 9.3 æ•´ä½“ä¼˜åŠ¿

- âœ… **æœ¬åœ°å¤„ç†**ï¼šæ— éœ€ç½‘ç»œï¼Œé€Ÿåº¦å¿«
- âœ… **å…è´¹å¼€æº**ï¼šæ—  API è´¹ç”¨
- âœ… **å‡†ç¡®æ€§é«˜**ï¼šç‰¹åˆ«æ˜¯ Word æ–‡æ¡£
- âœ… **æ˜“äºæ‰©å±•**ï¼šPython ç”Ÿæ€ä¸°å¯Œ

---

## åã€ä¸ Coze API çš„å¯¹æ¯”

| å¯¹æ¯”é¡¹       | æœ¬åœ°è§£ææ–¹æ¡ˆ                      | Coze API          |
| ------------ | --------------------------------- | ----------------- |
| **è§£æé€Ÿåº¦** | âœ… å¿«ï¼ˆæœ¬åœ°å¤„ç†ï¼‰                 | âš ï¸ æ…¢ï¼ˆç½‘ç»œè¯·æ±‚ï¼‰ |
| **å‡†ç¡®æ€§**   | âœ… é«˜ï¼ˆç‰¹åˆ«æ˜¯ Wordï¼‰              | âœ… é«˜ï¼ˆAIï¼‰       |
| **æˆæœ¬**     | âœ… å…è´¹                           | âŒ é«˜ï¼ˆAPI è´¹ç”¨ï¼‰ |
| **ç½‘ç»œä¾èµ–** | âœ… æ—                              | âŒ éœ€è¦           |
| **è¡¨æ ¼å¤„ç†** | âœ… ä¼˜ç§€ï¼ˆpdfplumber/python-docxï¼‰ | âœ… ä¼˜ç§€ï¼ˆAIï¼‰     |
| **ç»´æŠ¤éš¾åº¦** | âš ï¸ ä¸­ï¼ˆéœ€è¦ Python ç¯å¢ƒï¼‰         | âœ… ä½             |

**å»ºè®®**ï¼šæœ¬åœ°è§£æä½œä¸ºä¸»è¦æ–¹æ¡ˆï¼ŒCoze API ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆã€‚

---

## åä¸€ã€æµ‹è¯•å»ºè®®

### 11.1 ç¯å¢ƒæ£€æŸ¥

```bash
# æ£€æŸ¥Python
python3 --version

# æ£€æŸ¥LibreOffice
soffice --version

# æ£€æŸ¥Pythonä¾èµ–
python3 -c "import pdfplumber, docx; print('âœ… ä¾èµ–æ£€æŸ¥é€šè¿‡')"
```

### 11.2 åŠŸèƒ½æµ‹è¯•

1. **PDF è§£ææµ‹è¯•**

   - ç®€å• PDFï¼ˆçº¯æ–‡æœ¬ï¼‰
   - å¤æ‚ PDFï¼ˆè¡¨æ ¼ã€å¤šåˆ—å¸ƒå±€ï¼‰
   - å¤šé¡µ PDF

2. **Word è§£ææµ‹è¯•**

   - .docx æ–‡ä»¶è§£æ
   - .doc æ–‡ä»¶è½¬æ¢å’Œè§£æ
   - åŒ…å«è¡¨æ ¼çš„ Word æ–‡æ¡£
   - å¤šè¯­è¨€ Word æ–‡æ¡£

3. **é”™è¯¯å¤„ç†æµ‹è¯•**
   - ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼
   - æŸåçš„æ–‡ä»¶
   - LibreOffice æœªå®‰è£…æ—¶çš„é”™è¯¯æç¤º

---

## åäºŒã€å¸¸è§é—®é¢˜

### Q1: Ubuntu æœåŠ¡å™¨ç‰ˆæ²¡æœ‰ LibreOffice æ€ä¹ˆåŠï¼Ÿ

**ç­”**ï¼šå®‰è£…æ ¸å¿ƒç»„ä»¶ï¼š

```bash
sudo apt-get install libreoffice-core libreoffice-writer
```

### Q2: .doc è½¬æ¢å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

**ç­”**ï¼š

1. æ£€æŸ¥ LibreOffice æ˜¯å¦å®‰è£…ï¼š`soffice --version`
2. æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æŸå
3. æŸ¥çœ‹é”™è¯¯æ—¥å¿—

### Q3: Python è„šæœ¬æ‰§è¡Œå¤±è´¥ï¼Ÿ

**ç­”**ï¼š

1. æ£€æŸ¥ Python ç‰ˆæœ¬ï¼ˆéœ€è¦ 3.8+ï¼‰
2. æ£€æŸ¥ä¾èµ–æ˜¯å¦å®‰è£…ï¼š`pip list`
3. æ£€æŸ¥è„šæœ¬è·¯å¾„æ˜¯å¦æ­£ç¡®

### Q4: å¯ä»¥åŒæ—¶ä½¿ç”¨æœ¬åœ°è§£æå’Œ Coze API å—ï¼Ÿ

**ç­”**ï¼šå¯ä»¥ï¼å»ºè®®æœ¬åœ°è§£æä½œä¸ºä¸»è¦æ–¹æ¡ˆï¼ŒCoze API ä½œä¸ºå¤‡é€‰ã€‚

---

## åä¸‰ã€å®æ–½æ­¥éª¤

### é˜¶æ®µ 1ï¼šç¯å¢ƒå‡†å¤‡

1. âœ… å®‰è£… Python 3.8+
2. âœ… å®‰è£… LibreOfficeï¼ˆå¦‚æœéœ€è¦å¤„ç†.docï¼‰
3. âœ… å®‰è£… Python ä¾èµ–
4. âœ… å®‰è£… Node.js ä¾èµ–ï¼ˆmulterï¼‰

### é˜¶æ®µ 2ï¼šåç«¯å®ç°

1. âœ… åˆ›å»º Python è§£æè„šæœ¬ï¼ˆpdf_parser.py, word_parser.py, doc_to_docx.pyï¼‰
2. âœ… åˆ›å»º Node.js æœåŠ¡å±‚ï¼ˆdocumentParserService.jsï¼‰
3. âœ… åˆ›å»º API è·¯ç”±ï¼ˆdocumentParser.jsï¼‰
4. âœ… æ³¨å†Œè·¯ç”±

### é˜¶æ®µ 3ï¼šå‰ç«¯é›†æˆ

1. âœ… åˆ›å»ºå‰ç«¯ API è°ƒç”¨ï¼ˆdocumentParserApi.tsï¼‰
2. âœ… æ›´æ–° ProjectList ç»„ä»¶
3. âœ… æµ‹è¯•æ–‡ä»¶ä¸Šä¼ å’Œè§£æ

### é˜¶æ®µ 4ï¼šæµ‹è¯•å’Œä¼˜åŒ–

1. âœ… åŠŸèƒ½æµ‹è¯•
2. âœ… æ€§èƒ½æµ‹è¯•
3. âœ… é”™è¯¯å¤„ç†æµ‹è¯•
4. âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–

---

**æ›´æ–°æ—¥æœŸ**: 2025 å¹´ 1 æœˆ  
**ç»´æŠ¤è€…**: ç„é‰´ AI å›¢é˜Ÿ  
**ç‰ˆæœ¬**: v1.0.0

**ç„é‰´ç¼–ç¨‹ï¼Œä½¿å‘½å¿…è¾¾ï¼**
