# LabelMedix 数据库设计说明

## 概述

本文档描述了 LabelMedix 药品标签翻译系统的数据库设计，包括表结构、关联关系、约束条件以及常用查询示例。

## 数据库架构

### 表关系图

```
Users (用户表)
    ↓ (一对多)
Projects (项目表)
    ↓ (一对多)
CountryTranslationGroups (国别翻译组表)
    ↓ (一对多)
TranslationItems (翻译详情表)
```

### 表结构说明

#### 1. Users (用户表)

存储系统用户信息，包括管理员、普通用户等。

**字段说明：**

- `id`: 主键，自增
- `username`: 用户名，唯一，3-50 字符
- `email`: 邮箱，唯一
- `password_hash`: 密码哈希
- `full_name`: 全名
- `role`: 角色 (admin/user/reviewer)
- `department`: 部门
- `is_active`: 是否激活
- `reset_password_token`: 重置密码令牌
- `reset_password_expires`: 重置密码过期时间
- `last_login`: 最后登录时间

#### 2. Projects (项目表)

存储药品标签翻译项目的基本信息。

**字段说明：**

- `id`: 主键，自增
- `job_name`: 工单名称，唯一，如 "NZ-8864-4396-101"
- `job_description`: 工单描述
- `status`: 项目状态 (draft/processing/completed/failed)
- `total_files`: 上传文件总数
- `user_id`: 创建用户 ID，外键关联 Users 表
- `created_at`: 创建时间
- `updated_at`: 更新时间

#### 3. CountryTranslationGroups (国别翻译组表)

存储每个项目下不同国别代码的翻译组信息。

**字段说明：**

- `id`: 主键，自增
- `project_id`: 关联项目 ID，外键
- `country_code`: 国别代码，如 "AU", "CN", "MD", "NZ"
- `sequence_number`: 序号，项目内唯一
- `total_items`: 该组翻译条目总数
- `formatted_summary`: 格式化后的所有翻译汇总，对翻译详情表内容的汇总和重新整理
- `pdf_file_path`: 最终生成 PDF 文件的存储路径
- `created_at`: 创建时间
- `updated_at`: 更新时间

**约束条件：**

- 每个项目下每个国别代码只能有一条记录
- 每个项目下序号不能重复

#### 4. TranslationItems (翻译详情表)

存储具体的翻译条目内容。

**字段说明：**

- `id`: 主键，自增
- `group_id`: 关联翻译组 ID，外键
- `field_type`: 字段类型 (basic_info/number_field/drug_description)
- `original_text`: 原文
- `translated_text`: 翻译文本
- `item_order`: 组内排序
- `is_edited`: 是否被用户编辑过
- `created_at`: 创建时间
- `updated_at`: 更新时间

## 数据库表创建 SQL

### 1. 创建项目表

```sql
CREATE TABLE Projects (
    id INT AUTO_INCREMENT PRIMARY KEY,
    job_name VARCHAR(200) NOT NULL UNIQUE COMMENT '工单名称',
    job_description TEXT COMMENT '工单描述',
    status ENUM('draft', 'processing', 'completed', 'failed') DEFAULT 'draft' COMMENT '工单状态',
    total_files INT DEFAULT 0 COMMENT '上传文件总数',
    user_id INT COMMENT '创建用户ID',
    createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    KEY idx_job_name (job_name),
    KEY idx_user_id (user_id),
    KEY idx_status (status),
    FOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='项目工单表';
```

### 2. 创建国别翻译组表

```sql
CREATE TABLE CountryTranslationGroups (
    id INT AUTO_INCREMENT PRIMARY KEY,
    project_id INT NOT NULL COMMENT '关联项目ID',
    country_code VARCHAR(10) NOT NULL COMMENT '国别代码',
    sequence_number INT NOT NULL COMMENT '序号（项目内唯一）',
    total_items INT DEFAULT 0 COMMENT '该组翻译条目总数',
    formatted_summary TEXT COMMENT '格式化后的所有翻译汇总',
    pdf_file_path VARCHAR(500) COMMENT '最终生成 PDF 文件的存储路径',
    createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (project_id) REFERENCES Projects(id) ON DELETE CASCADE,
    UNIQUE KEY uk_project_country (project_id, country_code),
    UNIQUE KEY uk_project_sequence (project_id, sequence_number),
    KEY idx_project_country (project_id, country_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='国别翻译组表';
```

### 3. 创建翻译详情表

```sql
CREATE TABLE TranslationItems (
    id INT AUTO_INCREMENT PRIMARY KEY,
    group_id INT NOT NULL COMMENT '关联翻译组ID',
    field_type ENUM('basic_info', 'number_field', 'drug_description') NULL COMMENT '字段类型：基本信息、编号栏、药品说明',
    original_text TEXT NOT NULL COMMENT '原文',
    translated_text TEXT COMMENT '翻译文本',
    item_order INT NOT NULL COMMENT '组内排序',
    is_edited BOOLEAN DEFAULT FALSE COMMENT '是否被用户编辑过',
    createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (group_id) REFERENCES CountryTranslationGroups(id) ON DELETE CASCADE,
    KEY idx_group_order (group_id, item_order)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='翻译条目详情表';
```

## 常用查询示例

### 1. 查询操作

#### 获取所有项目列表（分页）

```sql
SELECT
    p.id,
    p.job_name,
    p.job_description,
    p.status,
    p.total_files,
    p.createdAt,
    u.username as creator
FROM Projects p
LEFT JOIN Users u ON p.user_id = u.id
ORDER BY p.createdAt DESC
LIMIT 10 OFFSET 0;
```

#### 获取项目详情及翻译统计

```sql
SELECT
    p.id,
    p.job_name,
    p.job_description,
    p.status,
    COUNT(DISTINCT ctg.country_code) as country_count,
    COUNT(ti.id) as total_translations
FROM Projects p
LEFT JOIN CountryTranslationGroups ctg ON p.id = ctg.project_id
LEFT JOIN TranslationItems ti ON ctg.id = ti.group_id
WHERE p.job_name = 'NZ-8864-4396-101'
GROUP BY p.id;
```

#### 获取项目所有翻译（按国别和序号排序）

```sql
SELECT
    p.job_name,
    ctg.country_code,
    ctg.sequence_number,
    ti.field_type,
    ti.original_text,
    ti.translated_text,
    ti.item_order,
    ti.is_edited
FROM Projects p
JOIN CountryTranslationGroups ctg ON p.id = ctg.project_id
JOIN TranslationItems ti ON ctg.id = ti.group_id
WHERE p.job_name = 'NZ-8864-4396-101'
ORDER BY ctg.sequence_number, ti.item_order;
```

#### 获取特定国别的翻译

```sql
SELECT
    ti.field_type,
    ti.original_text,
    ti.translated_text,
    ti.item_order,
    ti.is_edited
FROM Projects p
JOIN CountryTranslationGroups ctg ON p.id = ctg.project_id
JOIN TranslationItems ti ON ctg.id = ti.group_id
WHERE p.job_name = 'NZ-8864-4396-101'
  AND ctg.country_code = 'CN'
ORDER BY ti.item_order;
```

#### 获取用户创建的项目

```sql
SELECT
    p.id,
    p.job_name,
    p.status,
    p.createdAt,
    COUNT(ctg.id) as country_count
FROM Projects p
LEFT JOIN CountryTranslationGroups ctg ON p.id = ctg.project_id
WHERE p.user_id = 1
GROUP BY p.id
ORDER BY p.createdAt DESC;
```

### 2. 插入操作

#### 创建新项目

```sql
INSERT INTO Projects (job_name, job_description, status, user_id)
VALUES ('NZ-8864-4396-101', '新西兰药品标签翻译项目', 'draft', 1);
```

#### 批量插入国别翻译组

```sql
INSERT INTO CountryTranslationGroups (project_id, country_code, sequence_number, total_items)
VALUES
    (1, 'AU', 1, 3),
    (1, 'CN', 2, 3),
    (1, 'MD', 3, 3),
    (1, 'NZ', 4, 4);
```

#### 批量插入翻译条目

```sql
INSERT INTO TranslationItems (group_id, field_type, original_text, translated_text, item_order)
VALUES
    (1, 'basic_info', 'Protocol No.:', 'Protocol No.:', 1),
    (1, 'drug_description', 'BGB-43395 Tablets, XXX mg', 'BGB-43395 Tablets, XXX mg', 2),
    (1, 'drug_description', 'Each bottle contains 31 tablets.', 'Each bottle contains 31 tablets.', 3),
    (2, 'basic_info', '方案编号：', '方案编号：', 1),
    (2, 'drug_description', 'BGB-43395片, XXX mg', 'BGB-43395片, XXX mg', 2),
    (2, 'drug_description', '每瓶装有31片。', '每瓶装有31片。', 3);
```

### 3. 更新操作

#### 更新项目状态

```sql
UPDATE Projects
SET status = 'completed', updatedAt = CURRENT_TIMESTAMP
WHERE job_name = 'NZ-8864-4396-101';
```

#### 更新翻译内容

```sql
UPDATE TranslationItems
SET translated_text = '修改后的翻译内容',
    is_edited = TRUE,
    updatedAt = CURRENT_TIMESTAMP
WHERE id = 1;
```

#### 批量更新翻译组统计

```sql
UPDATE CountryTranslationGroups ctg
SET total_items = (
    SELECT COUNT(*)
    FROM TranslationItems ti
    WHERE ti.group_id = ctg.id
),
updatedAt = CURRENT_TIMESTAMP;
```

### 4. 删除操作

#### 删除项目（级联删除相关数据）

```sql
DELETE FROM Projects WHERE job_name = 'NZ-8864-4396-101';
```

#### 删除特定国别的翻译

```sql
DELETE ctg FROM CountryTranslationGroups ctg
JOIN Projects p ON ctg.project_id = p.id
WHERE p.job_name = 'NZ-8864-4396-101'
  AND ctg.country_code = 'MD';
```

#### 删除特定翻译条目

```sql
DELETE FROM TranslationItems
WHERE id = 1;
```

## 索引优化建议

### 1. 主要索引

- `Projects.job_name` - 工单名称查询
- `Projects.user_id` - 用户项目查询
- `Projects.status` - 状态筛选
- `CountryTranslationGroups.project_id` - 项目关联查询
- `TranslationItems.group_id` - 翻译组关联查询

### 2. 复合索引

- `(project_id, country_code)` - 国别查询
- `(project_id, sequence_number)` - 序号查询
- `(group_id, item_order)` - 排序查询

## 数据完整性约束

### 1. 外键约束

- `Projects.user_id` → `Users.id`
- `CountryTranslationGroups.project_id` → `Projects.id`
- `TranslationItems.group_id` → `CountryTranslationGroups.id`

### 2. 唯一约束

- `Projects.job_name` - 工单名称唯一
- `(project_id, country_code)` - 项目内国别代码唯一
- `(project_id, sequence_number)` - 项目内序号唯一

### 3. 检查约束

- `Projects.status` - 状态枚举值
- `TranslationItems.field_type` - 字段类型枚举值

## 性能优化建议

### 1. 查询优化

- 使用适当的索引
- 避免 SELECT \* 查询
- 使用 LIMIT 进行分页
- 合理使用 JOIN 操作

### 2. 数据维护

- 定期清理过期数据
- 监控表大小和查询性能
- 考虑数据归档策略

### 3. 备份策略

- 定期全量备份
- 增量备份
- 测试恢复流程

## 扩展性考虑

### 1. 水平扩展

- 考虑分库分表策略
- 读写分离
- 缓存层设计

### 2. 功能扩展

- 版本控制
- 审核流程
- 多语言支持
- 文件管理

---

**文档版本：** 1.0  
**创建日期：** 2025 年 10 月  
**最后更新：** 2025 年 10 月  
**维护人员：** 玄鉴 AI 团队
